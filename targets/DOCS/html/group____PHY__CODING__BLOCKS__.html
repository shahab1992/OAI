<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>OpenAirInterface: Channel Coding/Decoding Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="oai_logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenAirInterface
   </div>
   <div id="projectbrief">Full experimental OpenSource LTE implementation (Rel 8, partial Rel 10)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group____PHY__CODING__BLOCKS__.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Channel Coding/Decoding Functions<div class="ingroups"><a class="el" href="group____physical__layer__ref__implementation__.html">Physical Layer Reference Implementation</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae33732271b356b97f0ec8d3e496a264b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gae33732271b356b97f0ec8d3e496a264b">lte_segmentation</a> (uint8_t *input_buffer, uint8_t **output_buffers, uint32_t B, uint32_t *C, uint32_t *Cplus, uint32_t *Cminus, uint32_t *Kplus, uint32_t *Kminus, uint32_t *F)</td></tr>
<tr class="memdesc:gae33732271b356b97f0ec8d3e496a264b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements the LTE transport block segmentation algorithm from 36-212, V8.6 2009-03.  <a href="#gae33732271b356b97f0ec8d3e496a264b">More...</a><br/></td></tr>
<tr class="separator:gae33732271b356b97f0ec8d3e496a264b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ed2ac14db74c9fb7be26eb5a1f35df3"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga9ed2ac14db74c9fb7be26eb5a1f35df3">estimate_ue_tx_power</a> (uint32_t tbs, uint32_t nb_rb, uint8_t control_only, lte_prefix_type_t ncp, uint8_t use_srs)</td></tr>
<tr class="memdesc:ga9ed2ac14db74c9fb7be26eb5a1f35df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">this functions calculates the delta MCS in dB based on the lte_segmentation function  <a href="#ga9ed2ac14db74c9fb7be26eb5a1f35df3">More...</a><br/></td></tr>
<tr class="separator:ga9ed2ac14db74c9fb7be26eb5a1f35df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00091f91e5979fdaf82c4e1db0965591"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga00091f91e5979fdaf82c4e1db0965591">sub_block_interleaving_turbo</a> (uint32_t D, uint8_t *d, uint8_t *w)</td></tr>
<tr class="memdesc:ga00091f91e5979fdaf82c4e1db0965591"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the subblock interleaving algorithm from 36-212 (Release 8, 8.6 2009-03), pages 15-16. This function takes the d-sequence and generates the w-sequence. The nu-sequence from 36-212 is implicit.  <a href="#ga00091f91e5979fdaf82c4e1db0965591">More...</a><br/></td></tr>
<tr class="separator:ga00091f91e5979fdaf82c4e1db0965591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad21e1e94a475c59eddd0e757168546c4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gad21e1e94a475c59eddd0e757168546c4">sub_block_interleaving_cc</a> (uint32_t D, uint8_t *d, uint8_t *w)</td></tr>
<tr class="memdesc:gad21e1e94a475c59eddd0e757168546c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the subblock interleaving algorithm for convolutionally coded blocks from 36-212 (Release 8, 8.6 2009-03), pages 15-16. This function takes the d-sequence and generates the w-sequence. The nu-sequence from 36-212 is implicit.  <a href="#gad21e1e94a475c59eddd0e757168546c4">More...</a><br/></td></tr>
<tr class="separator:gad21e1e94a475c59eddd0e757168546c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0ff407f8470e0d4219afbe825bf249e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gaf0ff407f8470e0d4219afbe825bf249e">sub_block_deinterleaving_turbo</a> (uint32_t D, int16_t *d, int16_t *w)</td></tr>
<tr class="memdesc:gaf0ff407f8470e0d4219afbe825bf249e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the subblock deinterleaving algorithm from 36-212 (Release 8, 8.6 2009-03), pages 15-16. This function takes the w-sequence and generates the d-sequence. The nu-sequence from 36-212 is implicit.  <a href="#gaf0ff407f8470e0d4219afbe825bf249e">More...</a><br/></td></tr>
<tr class="separator:gaf0ff407f8470e0d4219afbe825bf249e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceb909729bc08323e7a6694ca83cbe5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gaceb909729bc08323e7a6694ca83cbe5d">sub_block_deinterleaving_cc</a> (uint32_t D, int8_t *d, int8_t *w)</td></tr>
<tr class="memdesc:gaceb909729bc08323e7a6694ca83cbe5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the subblock deinterleaving algorithm for convolutionally-coded data from 36-212 (Release 8, 8.6 2009-03), pages 15-16. This function takes the w-sequence and generates the d-sequence. The nu-sequence from 36-212 is implicit.  <a href="#gaceb909729bc08323e7a6694ca83cbe5d">More...</a><br/></td></tr>
<tr class="separator:gaceb909729bc08323e7a6694ca83cbe5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bdfcb8b38473042595ebb46f71b7475"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga1bdfcb8b38473042595ebb46f71b7475">generate_dummy_w</a> (uint32_t D, uint8_t *w, uint8_t F)</td></tr>
<tr class="memdesc:ga1bdfcb8b38473042595ebb46f71b7475"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a dummy interleaved sequence (first row) for receiver, in order to identify the NULL positions used to make the matrix complete.  <a href="#ga1bdfcb8b38473042595ebb46f71b7475">More...</a><br/></td></tr>
<tr class="separator:ga1bdfcb8b38473042595ebb46f71b7475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ff392d63bc5fbeb05c95b45590309ef"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga2ff392d63bc5fbeb05c95b45590309ef">generate_dummy_w_cc</a> (uint32_t D, uint8_t *w)</td></tr>
<tr class="memdesc:ga2ff392d63bc5fbeb05c95b45590309ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a dummy interleaved sequence (first row) for receiver (convolutionally-coded data), in order to identify the NULL positions used to make the matrix complete.  <a href="#ga2ff392d63bc5fbeb05c95b45590309ef">More...</a><br/></td></tr>
<tr class="separator:ga2ff392d63bc5fbeb05c95b45590309ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66f2aa75cbe406a0c6563d42b4fb0bf1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga66f2aa75cbe406a0c6563d42b4fb0bf1">lte_rate_matching_turbo</a> (uint32_t RTC, uint32_t G, uint8_t *w, uint8_t *e, uint8_t C, uint32_t Nsoft, uint8_t Mdlharq, uint8_t Kmimo, uint8_t rvidx, uint8_t Qm, uint8_t Nl, uint8_t r, uint8_t nb_rb, uint8_t m)</td></tr>
<tr class="separator:ga66f2aa75cbe406a0c6563d42b4fb0bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadef641e2046a0921c7fae3ac01f2ea83"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gadef641e2046a0921c7fae3ac01f2ea83">lte_rate_matching_cc</a> (uint32_t RCC, uint16_t E, uint8_t *w, uint8_t *e)</td></tr>
<tr class="memdesc:gadef641e2046a0921c7fae3ac01f2ea83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the LTE rate matching algorithm for Convolutionally-coded channels (e.g. BCH,DCI,UCI). It is taken directly from 36-212 (Rel 8 8.6, 2009-03), pages 16-18 )  <a href="#gadef641e2046a0921c7fae3ac01f2ea83">More...</a><br/></td></tr>
<tr class="separator:gadef641e2046a0921c7fae3ac01f2ea83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6e2a9b00f16198ca731dbda0665021e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gaa6e2a9b00f16198ca731dbda0665021e">lte_rate_matching_turbo_rx</a> (uint32_t RTC, uint32_t G, int16_t *w, uint8_t *dummy_w, int16_t *soft_input, uint8_t C, uint32_t Nsoft, uint8_t Mdlharq, uint8_t Kmimo, uint8_t rvidx, uint8_t clear, uint8_t Qm, uint8_t Nl, uint8_t r, uint32_t *E_out)</td></tr>
<tr class="memdesc:gaa6e2a9b00f16198ca731dbda0665021e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the LTE rate matching algorithm for Turbo-coded channels (e.g. DLSCH,ULSCH). It is taken directly from 36-212 (Rel 8 8.6, 2009-03), pages 16-18 )  <a href="#gaa6e2a9b00f16198ca731dbda0665021e">More...</a><br/></td></tr>
<tr class="separator:gaa6e2a9b00f16198ca731dbda0665021e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf052979b9fe48d2c8e7f2fc3cca170b9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gaf052979b9fe48d2c8e7f2fc3cca170b9">lte_rate_matching_turbo_rx_abs</a> (uint32_t RTC, uint32_t G, double *w, uint8_t *dummy_w, double *soft_input, uint8_t C, uint32_t Nsoft, uint8_t Mdlharq, uint8_t Kmimo, uint8_t rvidx, uint8_t clear, uint8_t Qm, uint8_t Nl, uint8_t r, uint32_t *E_out)</td></tr>
<tr class="separator:gaf052979b9fe48d2c8e7f2fc3cca170b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46344ae9f6583989b91bddebbd40fd18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga46344ae9f6583989b91bddebbd40fd18">lte_rate_matching_cc_rx</a> (uint32_t RCC, uint16_t E, int8_t *w, uint8_t *dummy_w, int8_t *soft_input)</td></tr>
<tr class="memdesc:ga46344ae9f6583989b91bddebbd40fd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the LTE rate matching algorithm for Convolutionally-coded channels (e.g. BCH,DCI,UCI). It is taken directly from 36-212 (Rel 8 8.6, 2009-03), pages 16-18 )  <a href="#ga46344ae9f6583989b91bddebbd40fd18">More...</a><br/></td></tr>
<tr class="separator:ga46344ae9f6583989b91bddebbd40fd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab87f652d71d9fa132961ff90af436edb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gab87f652d71d9fa132961ff90af436edb">ccodedot11_encode</a> (uint32_t numbytes, uint8_t *inPtr, uint8_t *outPtr, uint8_t puncturing)</td></tr>
<tr class="memdesc:gab87f652d71d9fa132961ff90af436edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements a rate 1/2 constraint length 7 convolutional code.  <a href="#gab87f652d71d9fa132961ff90af436edb">More...</a><br/></td></tr>
<tr class="separator:gab87f652d71d9fa132961ff90af436edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28d1475d8dd0de7b348fec0d344f4046"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga28d1475d8dd0de7b348fec0d344f4046">ccodedot11_init</a> (void)</td></tr>
<tr class="memdesc:ga28d1475d8dd0de7b348fec0d344f4046"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the generator polynomials for an 802.11 convolutional code.  <a href="#ga28d1475d8dd0de7b348fec0d344f4046">More...</a><br/></td></tr>
<tr class="separator:ga28d1475d8dd0de7b348fec0d344f4046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609854d3fc973d7c2f46d32b07ec8c4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga609854d3fc973d7c2f46d32b07ec8c4a">ccodedot11_init_inv</a> (void)</td></tr>
<tr class="memdesc:ga609854d3fc973d7c2f46d32b07ec8c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the trellis structure for decoding an 802.11 convolutional code.  <a href="#ga609854d3fc973d7c2f46d32b07ec8c4a">More...</a><br/></td></tr>
<tr class="separator:ga609854d3fc973d7c2f46d32b07ec8c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6437091245f948bd04ec258beb3153e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gad6437091245f948bd04ec258beb3153e">threegpplte_turbo_encoder</a> (uint8_t *input, uint16_t input_length_bytes, uint8_t *output, uint8_t F, uint16_t interleaver_f1, uint16_t interleaver_f2)</td></tr>
<tr class="separator:gad6437091245f948bd04ec258beb3153e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga561607dc210e4248e6856c2294513768"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga561607dc210e4248e6856c2294513768">ccodelte_encode</a> (int32_t numbits, uint8_t add_crc, uint8_t *inPtr, uint8_t *outPtr, uint16_t rnti)</td></tr>
<tr class="memdesc:ga561607dc210e4248e6856c2294513768"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements the LTE convolutional code of rate 1/3 with a constraint length of 7 bits. The inputs are bit packed in octets (from MSB to LSB). Trellis tail-biting is included here.  <a href="#ga561607dc210e4248e6856c2294513768">More...</a><br/></td></tr>
<tr class="separator:ga561607dc210e4248e6856c2294513768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga119f85954527db97d83059646108e321"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga119f85954527db97d83059646108e321">ccodelte_init</a> (void)</td></tr>
<tr class="memdesc:ga119f85954527db97d83059646108e321"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the generator polynomials for an LTE convolutional code.  <a href="#ga119f85954527db97d83059646108e321">More...</a><br/></td></tr>
<tr class="separator:ga119f85954527db97d83059646108e321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ad93b4be953fceb9f3d74352a22a60b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga5ad93b4be953fceb9f3d74352a22a60b">ccodelte_init_inv</a> (void)</td></tr>
<tr class="memdesc:ga5ad93b4be953fceb9f3d74352a22a60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the trellis structure for decoding an LTE convolutional code.  <a href="#ga5ad93b4be953fceb9f3d74352a22a60b">More...</a><br/></td></tr>
<tr class="separator:ga5ad93b4be953fceb9f3d74352a22a60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga735a382c14329fc5028a9832ab20cdb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga735a382c14329fc5028a9832ab20cdb6">ccodedab_init</a> (void)</td></tr>
<tr class="separator:ga735a382c14329fc5028a9832ab20cdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6640470b172057535e6015635f752fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gab6640470b172057535e6015635f752fd">ccodedab_init_inv</a> (void)</td></tr>
<tr class="separator:gab6640470b172057535e6015635f752fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6cc8403581715e08a7256a635fb211a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gaf6cc8403581715e08a7256a635fb211a">crcTableInit</a> (void)</td></tr>
<tr class="memdesc:gaf6cc8403581715e08a7256a635fb211a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the different crc tables.  <a href="#gaf6cc8403581715e08a7256a635fb211a">More...</a><br/></td></tr>
<tr class="separator:gaf6cc8403581715e08a7256a635fb211a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa70a2bdf38518e349a482343a310105c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gaa70a2bdf38518e349a482343a310105c">init_td8</a> (void)</td></tr>
<tr class="memdesc:gaa70a2bdf38518e349a482343a310105c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the tables for 8-bit LLR Turbo decoder.  <a href="#gaa70a2bdf38518e349a482343a310105c">More...</a><br/></td></tr>
<tr class="separator:gaa70a2bdf38518e349a482343a310105c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab60642dd3807b97ebe8a3e790a083552"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gab60642dd3807b97ebe8a3e790a083552">init_td16</a> (void)</td></tr>
<tr class="memdesc:gab60642dd3807b97ebe8a3e790a083552"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the tables for 16-bit LLR Turbo decoder.  <a href="#gab60642dd3807b97ebe8a3e790a083552">More...</a><br/></td></tr>
<tr class="separator:gab60642dd3807b97ebe8a3e790a083552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf32776998cc42046f04d052f6a66796b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gaf32776998cc42046f04d052f6a66796b">crc24a</a> (uint8_t *inPtr, int32_t bitlen)</td></tr>
<tr class="memdesc:gaf32776998cc42046f04d052f6a66796b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This computes a 24-bit crc ('a' variant for overall transport block) based on 3GPP UMTS/LTE specifications.  <a href="#gaf32776998cc42046f04d052f6a66796b">More...</a><br/></td></tr>
<tr class="separator:gaf32776998cc42046f04d052f6a66796b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f9c219d67936483118ff4bbca2633c4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga1f9c219d67936483118ff4bbca2633c4">crc24b</a> (uint8_t *inPtr, int32_t bitlen)</td></tr>
<tr class="memdesc:ga1f9c219d67936483118ff4bbca2633c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This computes a 24-bit crc ('b' variant for transport-block segments) based on 3GPP UMTS/LTE specifications.  <a href="#ga1f9c219d67936483118ff4bbca2633c4">More...</a><br/></td></tr>
<tr class="separator:ga1f9c219d67936483118ff4bbca2633c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccd46674578d92237c5a39bcb4922782"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gaccd46674578d92237c5a39bcb4922782">crc16</a> (uint8_t *inPtr, int32_t bitlen)</td></tr>
<tr class="memdesc:gaccd46674578d92237c5a39bcb4922782"><td class="mdescLeft">&#160;</td><td class="mdescRight">This computes a 16-bit crc based on 3GPP UMTS specifications.  <a href="#gaccd46674578d92237c5a39bcb4922782">More...</a><br/></td></tr>
<tr class="separator:gaccd46674578d92237c5a39bcb4922782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fe6f120ca61551d175da5b5da9ce83f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga5fe6f120ca61551d175da5b5da9ce83f">crc12</a> (uint8_t *inPtr, int32_t bitlen)</td></tr>
<tr class="memdesc:ga5fe6f120ca61551d175da5b5da9ce83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This computes a 12-bit crc based on 3GPP UMTS specifications.  <a href="#ga5fe6f120ca61551d175da5b5da9ce83f">More...</a><br/></td></tr>
<tr class="separator:ga5fe6f120ca61551d175da5b5da9ce83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60feab36aeac1c3cb25f93b454d48e5e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga60feab36aeac1c3cb25f93b454d48e5e">crc8</a> (uint8_t *inPtr, int32_t bitlen)</td></tr>
<tr class="memdesc:ga60feab36aeac1c3cb25f93b454d48e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This computes a 8-bit crc based on 3GPP UMTS specifications.  <a href="#ga60feab36aeac1c3cb25f93b454d48e5e">More...</a><br/></td></tr>
<tr class="separator:ga60feab36aeac1c3cb25f93b454d48e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a175da7174992f52a147e0fd670c9d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga6a175da7174992f52a147e0fd670c9d2">phy_viterbi_dot11_sse2</a> (int8_t *y, uint8_t *decoded_bytes, uint16_t n)</td></tr>
<tr class="separator:ga6a175da7174992f52a147e0fd670c9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab3aee504b6478899fe96751d1a6c2ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gaab3aee504b6478899fe96751d1a6c2ce">phy_viterbi_lte_sse2</a> (int8_t *y, uint8_t *decoded_bytes, uint16_t n)</td></tr>
<tr class="memdesc:gaab3aee504b6478899fe96751d1a6c2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine performs a SIMD optmized Viterbi decoder for the LTE 64-state tail-biting convolutional code.  <a href="#gaab3aee504b6478899fe96751d1a6c2ce">More...</a><br/></td></tr>
<tr class="separator:gaab3aee504b6478899fe96751d1a6c2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7445537214a286887212724092b42928"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga7445537214a286887212724092b42928">phy_generate_viterbi_tables</a> (void)</td></tr>
<tr class="memdesc:ga7445537214a286887212724092b42928"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine initializes metric tables for the optimized Viterbi decoder.  <a href="#ga7445537214a286887212724092b42928">More...</a><br/></td></tr>
<tr class="separator:ga7445537214a286887212724092b42928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad80bd0a148adbc26786a18c31ae48200"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gad80bd0a148adbc26786a18c31ae48200">phy_generate_viterbi_tables_lte</a> (void)</td></tr>
<tr class="memdesc:gad80bd0a148adbc26786a18c31ae48200"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine initializes metric tables for the optimized LTE Viterbi decoder.  <a href="#gad80bd0a148adbc26786a18c31ae48200">More...</a><br/></td></tr>
<tr class="separator:gad80bd0a148adbc26786a18c31ae48200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52a676ed0350c6383351d271f0dab26a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga52a676ed0350c6383351d271f0dab26a">rate_matching</a> (uint32_t N_coded, uint32_t N_input, uint8_t *inPtr, uint8_t N_bps, uint32_t off)</td></tr>
<tr class="memdesc:ga52a676ed0350c6383351d271f0dab26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine performs random puncturing of a coded sequence.  <a href="#ga52a676ed0350c6383351d271f0dab26a">More...</a><br/></td></tr>
<tr class="separator:ga52a676ed0350c6383351d271f0dab26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a85e23435cd27a8dcb19d9f705a1f8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga16a85e23435cd27a8dcb19d9f705a1f8">rate_matching_lte</a> (uint32_t N_coded, uint32_t N_input, uint8_t *inPtr, uint32_t off)</td></tr>
<tr class="separator:ga16a85e23435cd27a8dcb19d9f705a1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga148b8d028ac6a0458b694b29534ba26f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga148b8d028ac6a0458b694b29534ba26f">phy_threegpplte_turbo_decoder16</a> (int16_t *y, uint8_t *decoded_bytes, uint16_t n, uint16_t interleaver_f1, uint16_t interleaver_f2, uint8_t max_iterations, uint8_t crc_type, uint8_t F, time_stats_t *init_stats, time_stats_t *alpha_stats, time_stats_t *beta_stats, time_stats_t *gamma_stats, time_stats_t *ext_stats, time_stats_t *intl1_stats, time_stats_t *intl2_stats)</td></tr>
<tr class="memdesc:ga148b8d028ac6a0458b694b29534ba26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine performs max-logmap detection for the 3GPP turbo code (with termination). It is optimized for SIMD processing and 16-bit LLR arithmetic, and requires SSE2,SSSE3 and SSE4.1 (gcc &gt;=4.3 and appropriate CPU)  <a href="#ga148b8d028ac6a0458b694b29534ba26f">More...</a><br/></td></tr>
<tr class="separator:ga148b8d028ac6a0458b694b29534ba26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2319916c38d978827d364cb7758c732"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#gaf2319916c38d978827d364cb7758c732">phy_threegpplte_turbo_decoder8</a> (int16_t *y, uint8_t *decoded_bytes, uint16_t n, uint16_t interleaver_f1, uint16_t interleaver_f2, uint8_t max_iterations, uint8_t crc_type, uint8_t F, time_stats_t *init_stats, time_stats_t *alpha_stats, time_stats_t *beta_stats, time_stats_t *gamma_stats, time_stats_t *ext_stats, time_stats_t *intl1_stats, time_stats_t *intl2_stats)</td></tr>
<tr class="memdesc:gaf2319916c38d978827d364cb7758c732"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine performs max-logmap detection for the 3GPP turbo code (with termination). It is optimized for SIMD processing and 8-bit LLR arithmetic, and requires SSE2,SSSE3 and SSE4.1 (gcc &gt;=4.3 and appropriate CPU)  <a href="#gaf2319916c38d978827d364cb7758c732">More...</a><br/></td></tr>
<tr class="separator:gaf2319916c38d978827d364cb7758c732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga342f4e2723cc3a012260e7419346f4bc"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group____PHY__CODING__BLOCKS__.html#ga342f4e2723cc3a012260e7419346f4bc">phy_threegpplte_turbo_decoder_scalar</a> (int16_t *y, uint8_t *decoded_bytes, uint16_t n, uint16_t interleaver_f1, uint16_t interleaver_f2, uint8_t max_iterations, uint8_t crc_type, uint8_t F, uint8_t inst)</td></tr>
<tr class="separator:ga342f4e2723cc3a012260e7419346f4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module is responsible for procedures related to channel coding/decoding, rate-matching, segementation and interleaving. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae33732271b356b97f0ec8d3e496a264b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lte_segmentation </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>input_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>output_buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>Cplus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>Cminus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>Kplus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>Kminus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements the LTE transport block segmentation algorithm from 36-212, V8.6 2009-03. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_buffer</td><td></td></tr>
    <tr><td class="paramname">output_buffers</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">C</td><td></td></tr>
    <tr><td class="paramname">Cplus</td><td></td></tr>
    <tr><td class="paramname">Cminus</td><td></td></tr>
    <tr><td class="paramname">Kplus</td><td></td></tr>
    <tr><td class="paramname">Kminus</td><td></td></tr>
    <tr><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9ed2ac14db74c9fb7be26eb5a1f35df3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t estimate_ue_tx_power </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nb_rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>control_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lte_prefix_type_t&#160;</td>
          <td class="paramname"><em>ncp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>use_srs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this functions calculates the delta MCS in dB based on the lte_segmentation function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tbs</td><td>transport block size </td></tr>
    <tr><td class="paramname">nb_rb</td><td>number of required rb </td></tr>
    <tr><td class="paramname">control_only</td><td>a flag for the type of data </td></tr>
    <tr><td class="paramname">ncp</td><td>cyclic prefix </td></tr>
    <tr><td class="paramname">use_srs</td><td>a flag indicating the use of srs in the current SF </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ue_tx_power estimated ue tx power = delat_ mcs + bw_factor </dd></dl>

</div>
</div>
<a class="anchor" id="ga00091f91e5979fdaf82c4e1db0965591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sub_block_interleaving_turbo </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the subblock interleaving algorithm from 36-212 (Release 8, 8.6 2009-03), pages 15-16. This function takes the d-sequence and generates the w-sequence. The nu-sequence from 36-212 is implicit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Number of systematic bits plus 4 (plus 4 for termination) </td></tr>
    <tr><td class="paramname">d</td><td>Pointer to input (d-sequence, turbo code output) </td></tr>
    <tr><td class="paramname">w</td><td>Pointer to output (w-sequence, interleaver output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interleaving matrix cardinality ( <img class="formulaInl" alt="$K_{\pi}$" src="form_48.png"/> from 36-212) </dd></dl>

</div>
</div>
<a class="anchor" id="gad21e1e94a475c59eddd0e757168546c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sub_block_interleaving_cc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the subblock interleaving algorithm for convolutionally coded blocks from 36-212 (Release 8, 8.6 2009-03), pages 15-16. This function takes the d-sequence and generates the w-sequence. The nu-sequence from 36-212 is implicit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Number of input bits </td></tr>
    <tr><td class="paramname">d</td><td>Pointer to input (d-sequence, convolutional code output) </td></tr>
    <tr><td class="paramname">w</td><td>Pointer to output (w-sequence, interleaver output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interleaving matrix cardinality ( <img class="formulaInl" alt="$K_{\pi}$" src="form_48.png"/> from 36-212) </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0ff407f8470e0d4219afbe825bf249e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sub_block_deinterleaving_turbo </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the subblock deinterleaving algorithm from 36-212 (Release 8, 8.6 2009-03), pages 15-16. This function takes the w-sequence and generates the d-sequence. The nu-sequence from 36-212 is implicit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Number of systematic bits plus 4 (plus 4 for termination) </td></tr>
    <tr><td class="paramname">d</td><td>Pointer to output (d-sequence, turbo code output) </td></tr>
    <tr><td class="paramname">w</td><td>Pointer to input (w-sequence, interleaver output) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaceb909729bc08323e7a6694ca83cbe5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sub_block_deinterleaving_cc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the subblock deinterleaving algorithm for convolutionally-coded data from 36-212 (Release 8, 8.6 2009-03), pages 15-16. This function takes the w-sequence and generates the d-sequence. The nu-sequence from 36-212 is implicit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Number of input bits </td></tr>
    <tr><td class="paramname">d</td><td>Pointer to output (d-sequence, turbo code output) </td></tr>
    <tr><td class="paramname">w</td><td>Pointer to input (w-sequence, interleaver output) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1bdfcb8b38473042595ebb46f71b7475"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">generate_dummy_w </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates a dummy interleaved sequence (first row) for receiver, in order to identify the NULL positions used to make the matrix complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Number of systematic bits plus 4 (plus 4 for termination) </td></tr>
    <tr><td class="paramname">w</td><td>This is the dummy sequence (first row), it will contain zeros and at most 31 "LTE_NULL" values </td></tr>
    <tr><td class="paramname">F</td><td>Number of filler bits due added during segmentation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interleaving matrix cardinality ( <img class="formulaInl" alt="$K_{\pi}$" src="form_48.png"/> from 36-212) </dd></dl>

</div>
</div>
<a class="anchor" id="ga2ff392d63bc5fbeb05c95b45590309ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">generate_dummy_w_cc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates a dummy interleaved sequence (first row) for receiver (convolutionally-coded data), in order to identify the NULL positions used to make the matrix complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Number of systematic bits plus 4 (plus 4 for termination) </td></tr>
    <tr><td class="paramname">w</td><td>This is the dummy sequence (first row), it will contain zeros and at most 31 "LTE_NULL" values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interleaving matrix cardinality ( <img class="formulaInl" alt="$K_{\pi}$" src="form_48.png"/> from 36-212) </dd></dl>

</div>
</div>
<a class="anchor" id="ga66f2aa75cbe406a0c6563d42b4fb0bf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lte_rate_matching_turbo </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>RTC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Nsoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Mdlharq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Kmimo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rvidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Qm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nb_rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gadef641e2046a0921c7fae3ac01f2ea83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lte_rate_matching_cc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>RCC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the LTE rate matching algorithm for Convolutionally-coded channels (e.g. BCH,DCI,UCI). It is taken directly from 36-212 (Rel 8 8.6, 2009-03), pages 16-18 ) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RCC</td><td>R^CC_subblock from subblock interleaver (number of rows in interleaving matrix) for up to 8 segments </td></tr>
    <tr><td class="paramname">E</td><td>Number of coded channel bits </td></tr>
    <tr><td class="paramname">w</td><td>This is a pointer to the w-sequence (second interleaver output) </td></tr>
    <tr><td class="paramname">e</td><td>This is a pointer to the e-sequence (rate matching output, channel input/output bits) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><img class="formulaInl" alt="$E$" src="form_49.png"/>, the number of coded bits per segment </dd></dl>

</div>
</div>
<a class="anchor" id="gaa6e2a9b00f16198ca731dbda0665021e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lte_rate_matching_turbo_rx </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>RTC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dummy_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>soft_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Nsoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Mdlharq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Kmimo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rvidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>clear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Qm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>E_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the LTE rate matching algorithm for Turbo-coded channels (e.g. DLSCH,ULSCH). It is taken directly from 36-212 (Rel 8 8.6, 2009-03), pages 16-18 ) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RTC</td><td>R^TC_subblock from subblock interleaver (number of rows in interleaving matrix) </td></tr>
    <tr><td class="paramname">G</td><td>This the number of coded transport bits allocated in sub-frame </td></tr>
    <tr><td class="paramname">w</td><td>This is a pointer to the soft w-sequence (second interleaver output) with soft-combined outputs from successive HARQ rounds </td></tr>
    <tr><td class="paramname">dummy_w</td><td>This is the first row of the interleaver matrix for identifying/discarding the "LTE-NULL" positions </td></tr>
    <tr><td class="paramname">soft_input</td><td>This is a pointer to the soft channel output </td></tr>
    <tr><td class="paramname">C</td><td>Number of segments (codewords) in the sub-frame </td></tr>
    <tr><td class="paramname">Nsoft</td><td>Total number of soft bits (from UE capabilities in 36-306) </td></tr>
    <tr><td class="paramname">Mdlharq</td><td>Number of HARQ rounds </td></tr>
    <tr><td class="paramname">Kmimo</td><td>MIMO capability for this DLSCH (0 = no MIMO) </td></tr>
    <tr><td class="paramname">rvidx</td><td>round index (0-3) </td></tr>
    <tr><td class="paramname">clear</td><td>1 means clear soft buffer (start of HARQ round) </td></tr>
    <tr><td class="paramname">Qm</td><td>modulation order (2,4,6) </td></tr>
    <tr><td class="paramname">Nl</td><td>number of layers (1,2) </td></tr>
    <tr><td class="paramname">r</td><td>segment number </td></tr>
    <tr><td class="paramname">E_out</td><td>the number of coded bits per segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="gaf052979b9fe48d2c8e7f2fc3cca170b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lte_rate_matching_turbo_rx_abs </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>RTC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dummy_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>soft_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Nsoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Mdlharq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Kmimo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rvidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>clear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Qm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>E_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga46344ae9f6583989b91bddebbd40fd18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lte_rate_matching_cc_rx </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>RCC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dummy_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>soft_input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the LTE rate matching algorithm for Convolutionally-coded channels (e.g. BCH,DCI,UCI). It is taken directly from 36-212 (Rel 8 8.6, 2009-03), pages 16-18 ) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RCC</td><td>R^CC_subblock from subblock interleaver (number of rows in interleaving matrix) </td></tr>
    <tr><td class="paramname">E</td><td>This the number of coded bits allocated for channel </td></tr>
    <tr><td class="paramname">w</td><td>This is a pointer to the soft w-sequence (second interleaver output) with soft-combined outputs from successive HARQ rounds </td></tr>
    <tr><td class="paramname">dummy_w</td><td>This is the first row of the interleaver matrix for identifying/discarding the "LTE-NULL" positions </td></tr>
    <tr><td class="paramname">soft_input</td><td>This is a pointer to the soft channel output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><img class="formulaInl" alt="$E$" src="form_49.png"/>, the number of coded bits per segment </dd></dl>

</div>
</div>
<a class="anchor" id="gab87f652d71d9fa132961ff90af436edb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccodedot11_encode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>inPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>outPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>puncturing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements a rate 1/2 constraint length 7 convolutional code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numbytes</td><td>Number of bytes to encode </td></tr>
    <tr><td class="paramname">inPtr</td><td>Pointer to input buffer </td></tr>
    <tr><td class="paramname">outPtr</td><td>Pointer to output buffer </td></tr>
    <tr><td class="paramname">puncturing</td><td>Puncturing pattern (Not used at present, to be removed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga28d1475d8dd0de7b348fec0d344f4046"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccodedot11_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the generator polynomials for an 802.11 convolutional code. </p>

</div>
</div>
<a class="anchor" id="ga609854d3fc973d7c2f46d32b07ec8c4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccodedot11_init_inv </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the trellis structure for decoding an 802.11 convolutional code. </p>

</div>
</div>
<a class="anchor" id="gad6437091245f948bd04ec258beb3153e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void threegpplte_turbo_encoder </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>input_length_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interleaver_f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interleaver_f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga561607dc210e4248e6856c2294513768"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccodelte_encode </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>numbits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>add_crc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>inPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>outPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rnti</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements the LTE convolutional code of rate 1/3 with a constraint length of 7 bits. The inputs are bit packed in octets (from MSB to LSB). Trellis tail-biting is included here. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numbits</td><td>Number of bits to encode </td></tr>
    <tr><td class="paramname">add_crc</td><td>crc to be appended (8 bits) if add_crc = 1 </td></tr>
    <tr><td class="paramname">inPtr</td><td>Pointer to input buffer </td></tr>
    <tr><td class="paramname">outPtr</td><td>Pointer to output buffer </td></tr>
    <tr><td class="paramname">rnti</td><td>RNTI for CRC scrambling </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga119f85954527db97d83059646108e321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccodelte_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the generator polynomials for an LTE convolutional code. </p>
<p>This function initializes the generator polynomials for an DAB convolutional code (first 3 bits). </p>

</div>
</div>
<a class="anchor" id="ga5ad93b4be953fceb9f3d74352a22a60b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccodelte_init_inv </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the trellis structure for decoding an LTE convolutional code. </p>
<p>This function initializes the trellis structure for decoding an DAB convolutional code (first 3 bits). </p>

</div>
</div>
<a class="anchor" id="ga735a382c14329fc5028a9832ab20cdb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccodedab_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gab6640470b172057535e6015635f752fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccodedab_init_inv </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf6cc8403581715e08a7256a635fb211a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crcTableInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the different crc tables. </p>

</div>
</div>
<a class="anchor" id="gaa70a2bdf38518e349a482343a310105c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_td8 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the tables for 8-bit LLR Turbo decoder. </p>

</div>
</div>
<a class="anchor" id="gab60642dd3807b97ebe8a3e790a083552"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_td16 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the tables for 16-bit LLR Turbo decoder. </p>

</div>
</div>
<a class="anchor" id="gaf32776998cc42046f04d052f6a66796b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t crc24a </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>inPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>bitlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This computes a 24-bit crc ('a' variant for overall transport block) based on 3GPP UMTS/LTE specifications. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inPtr</td><td>Pointer to input byte stream </td></tr>
    <tr><td class="paramname">bitlen</td><td>length of inputs in bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1f9c219d67936483118ff4bbca2633c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t crc24b </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>inPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>bitlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This computes a 24-bit crc ('b' variant for transport-block segments) based on 3GPP UMTS/LTE specifications. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inPtr</td><td>Pointer to input byte stream </td></tr>
    <tr><td class="paramname">bitlen</td><td>length of inputs in bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaccd46674578d92237c5a39bcb4922782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t crc16 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>inPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>bitlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This computes a 16-bit crc based on 3GPP UMTS specifications. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inPtr</td><td>Pointer to input byte stream </td></tr>
    <tr><td class="paramname">bitlen</td><td>length of inputs in bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5fe6f120ca61551d175da5b5da9ce83f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t crc12 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>inPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>bitlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This computes a 12-bit crc based on 3GPP UMTS specifications. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inPtr</td><td>Pointer to input byte stream </td></tr>
    <tr><td class="paramname">bitlen</td><td>length of inputs in bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga60feab36aeac1c3cb25f93b454d48e5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t crc8 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>inPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>bitlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This computes a 8-bit crc based on 3GPP UMTS specifications. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inPtr</td><td>Pointer to input byte stream </td></tr>
    <tr><td class="paramname">bitlen</td><td>length of inputs in bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6a175da7174992f52a147e0fd670c9d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void phy_viterbi_dot11_sse2 </td>
          <td>(</td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>decoded_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaab3aee504b6478899fe96751d1a6c2ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void phy_viterbi_lte_sse2 </td>
          <td>(</td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>decoded_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine performs a SIMD optmized Viterbi decoder for the LTE 64-state tail-biting convolutional code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Pointer to soft input (coded on 8-bits but should be limited to 4-bit precision to avoid overflow) </td></tr>
    <tr><td class="paramname">decoded_bytes</td><td>Pointer to decoded output </td></tr>
    <tr><td class="paramname">n</td><td>Length of input/trellis depth in bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7445537214a286887212724092b42928"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void phy_generate_viterbi_tables </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine initializes metric tables for the optimized Viterbi decoder. </p>

</div>
</div>
<a class="anchor" id="gad80bd0a148adbc26786a18c31ae48200"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void phy_generate_viterbi_tables_lte </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine initializes metric tables for the optimized LTE Viterbi decoder. </p>

</div>
</div>
<a class="anchor" id="ga52a676ed0350c6383351d271f0dab26a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rate_matching </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>N_coded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>N_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>inPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>N_bps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine performs random puncturing of a coded sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N_coded</td><td>Number of coding bits to be output </td></tr>
    <tr><td class="paramname">N_input</td><td>Number of input bits </td></tr>
    <tr><td class="paramname">*inPtr</td><td>Pointer to coded input </td></tr>
    <tr><td class="paramname">N_bps</td><td>Number of modulation bits per symbol (1,2,4) </td></tr>
    <tr><td class="paramname">off</td><td>Offset for seed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga16a85e23435cd27a8dcb19d9f705a1f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rate_matching_lte </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>N_coded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>N_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>inPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga148b8d028ac6a0458b694b29534ba26f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t phy_threegpplte_turbo_decoder16 </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>decoded_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interleaver_f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interleaver_f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>max_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>crc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_stats_t *&#160;</td>
          <td class="paramname"><em>init_stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_stats_t *&#160;</td>
          <td class="paramname"><em>alpha_stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_stats_t *&#160;</td>
          <td class="paramname"><em>beta_stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_stats_t *&#160;</td>
          <td class="paramname"><em>gamma_stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_stats_t *&#160;</td>
          <td class="paramname"><em>ext_stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_stats_t *&#160;</td>
          <td class="paramname"><em>intl1_stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_stats_t *&#160;</td>
          <td class="paramname"><em>intl2_stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine performs max-logmap detection for the 3GPP turbo code (with termination). It is optimized for SIMD processing and 16-bit LLR arithmetic, and requires SSE2,SSSE3 and SSE4.1 (gcc &gt;=4.3 and appropriate CPU) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>LLR input (16-bit precision) </td></tr>
    <tr><td class="paramname">decoded_bytes</td><td>Pointer to decoded output </td></tr>
    <tr><td class="paramname">n</td><td>number of coded bits (including tail bits) </td></tr>
    <tr><td class="paramname">max_iterations</td><td>The maximum number of iterations to perform </td></tr>
    <tr><td class="paramname">interleaver_f1</td><td>F1 generator </td></tr>
    <tr><td class="paramname">interleaver_f2</td><td>F2 generator </td></tr>
    <tr><td class="paramname">crc_type</td><td>Length of 3GPPLTE crc (CRC24a,CRC24b,CRC16,CRC8) </td></tr>
    <tr><td class="paramname">F</td><td>Number of filler bits at start of packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of iterations used (this is 1+max if incorrect crc or if crc_len=0) </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2319916c38d978827d364cb7758c732"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t phy_threegpplte_turbo_decoder8 </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>decoded_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interleaver_f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interleaver_f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>max_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>crc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_stats_t *&#160;</td>
          <td class="paramname"><em>init_stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_stats_t *&#160;</td>
          <td class="paramname"><em>alpha_stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_stats_t *&#160;</td>
          <td class="paramname"><em>beta_stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_stats_t *&#160;</td>
          <td class="paramname"><em>gamma_stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_stats_t *&#160;</td>
          <td class="paramname"><em>ext_stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_stats_t *&#160;</td>
          <td class="paramname"><em>intl1_stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_stats_t *&#160;</td>
          <td class="paramname"><em>intl2_stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine performs max-logmap detection for the 3GPP turbo code (with termination). It is optimized for SIMD processing and 8-bit LLR arithmetic, and requires SSE2,SSSE3 and SSE4.1 (gcc &gt;=4.3 and appropriate CPU) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>LLR input (16-bit precision) </td></tr>
    <tr><td class="paramname">decoded_bytes</td><td>Pointer to decoded output </td></tr>
    <tr><td class="paramname">n</td><td>number of coded bits (including tail bits) </td></tr>
    <tr><td class="paramname">max_iterations</td><td>The maximum number of iterations to perform </td></tr>
    <tr><td class="paramname">interleaver_f1</td><td>F1 generator </td></tr>
    <tr><td class="paramname">interleaver_f2</td><td>F2 generator </td></tr>
    <tr><td class="paramname">crc_type</td><td>Length of 3GPPLTE crc (CRC24a,CRC24b,CRC16,CRC8) </td></tr>
    <tr><td class="paramname">F</td><td>Number of filler bits at start of packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of iterations used (this is 1+max if incorrect crc or if crc_len=0) </dd></dl>

</div>
</div>
<a class="anchor" id="ga342f4e2723cc3a012260e7419346f4bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t phy_threegpplte_turbo_decoder_scalar </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>decoded_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interleaver_f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interleaver_f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>max_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>crc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>inst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Sep 11 2015 02:35:10 for OpenAirInterface by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
